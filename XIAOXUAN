from pathlib import Path
import hashlib, shutil, os, subprocess, sys
import re

TARGET_DIR = Path("/data/data/com.termux/files/usr/bin")
QEMU_SRC = Path("/data/user/0/com.termux/files/home/XIAOXUAN/qemu-i386")
QEMU_DST = TARGET_DIR / "qemu-i386"

def sync_file(src: Path, dst: Path):
    shutil.copy2(src, dst)
    dst.chmod(0o755)

def release_self():
    script = """cd XIAOXUAN
chmod +x XIAOXUAN
./XIAOXUAN
"""
    target = TARGET_DIR / "XIAOXUAN启动"
    target.write_text(script)
    target.chmod(0o755)

TARGET_DIR.mkdir(parents=True, exist_ok=True)
release_self()
sync_file(QEMU_SRC, QEMU_DST)


import requests
import json
import hashlib
import random
import uuid
import time
import datetime
import re

import os, shutil, subprocess, sys, tempfile, struct
from pathlib import Path
import time

BASE        = Path("/storage/emulated/0/Download/XIAOXUAN")
AASE        = Path("/data/data/com.termux/files/home/XIAOXUAN")
ORIG_PAK    = BASE / "原版PAK"
UNPACK_DIR  = BASE / "解包值"
PACK_DIR    = BASE / "打包值"
OUT_PAK_DIR = BASE / "打包输出"
QBMS_EXE    = AASE / "quickbms_4gb_files"
for d in (ORIG_PAK, UNPACK_DIR, PACK_DIR, OUT_PAK_DIR):
    d.mkdir(parents=True, exist_ok=True)

BMS_DAT = r'''comtype copy
math NO_TAIL_INFO = 1
math VERSION = 3
math GUESS_NAMES = 0
quickbmsver "0.8.4"
math TOC_FILE = 0
math TOC_FILE5 = -5
set AES_KEY binary ""
putarray 10 -1 ""
math AES_KEY_IS_SET = 0
math ALTERNATIVE_MODE = 0
get ARCHIVE_NAME basename
get ARCHIVE_PATH FILEPATH
math CHUNK_OFFSET_ABSOLUTE = -1
math WORKAROUND = 0
if NO_TAIL_INFO != 0
    get OFFSET asize
    math ALTERNATIVE_MODE = 1
endif
if ALTERNATIVE_MODE == 0
    get FILES long TOC_FILE
else
    math FILES = 0x7fffffff
    math MAX_OFF = OFFSET
    goto 0
    set NAME string ""
    set BASE_NAME string ""
endif
math CHUNK_SIZE = 0x10000
for i = 0 < FILES
    string NAME p "%08d" i
    string NAME + ".dat"
    savepos TMP_OFF TOC_FILE
    getdstring HASH 20
    get OFFSET longlong TOC_FILE
    get SIZE longlong TOC_FILE
    get ZIP long TOC_FILE
    get ZSIZE longlong TOC_FILE
    getdstring DUMMY2 21 TOC_FILE
    if OFFSET != 0
        cleanexit
    endif
    math CHUNKS = 0
    math ENCRYPTED = 0
    if VERSION >= 3
        if ZIP != 0
            get CHUNKS long TOC_FILE
            for x = 0 < CHUNKS
                get CHUNK_OFFSET longlong TOC_FILE
                get CHUNK_END_OFFSET longlong TOC_FILE
                putarray 0 x CHUNK_OFFSET
                putarray 1 x CHUNK_END_OFFSET
            next x
        endif
        get CHUNK_SIZE long TOC_FILE
        if WORKAROUND != 2
            get ENCRYPTED byte TOC_FILE
        endif
    endif
    if WORKAROUND == 1
        if ARCHIVE_NAME == "0"
            math ENCRYPTED = 0
        endif
    endif
    if ALTERNATIVE_MODE != 0
        savepos TMP_OFF TOC_FILE
        math OFFSET + TMP_OFF
    endif
    if ZIP & 1
        comtype zlib
    elif ZIP & 0x06
        comtype zstd
    else
        math ZIP = 0
    endif
    filexor 0x79
    if CHUNKS > 0
        append
        math TMP_SIZE = SIZE
        if CHUNK_OFFSET_ABSOLUTE < 0 && OFFSET != 0
            getarray CHUNK_OFFSET 0 0
            if CHUNK_OFFSET u< OFFSET || VERSION >= 5
                math CHUNK_OFFSET_ABSOLUTE = 0
            else
                math CHUNK_OFFSET_ABSOLUTE = 1
            endif
        endif
        for x = 0 < CHUNKS
            getarray CHUNK_OFFSET 0 x
            getarray CHUNK_END_OFFSET 1 x
            math CHUNK_ZSIZE = CHUNK_END_OFFSET
            math CHUNK_ZSIZE - CHUNK_OFFSET
            math CHUNK_XSIZE = CHUNK_ZSIZE
            if TMP_SIZE u< CHUNK_SIZE
                math CHUNK_SIZE = TMP_SIZE
            endif
            if CHUNK_OFFSET_ABSOLUTE == 0
                math CHUNK_OFFSET = OFFSET
            endif
            if ENCRYPTED == 0
                filexor ""
            endif
            if ZIP == 0
                log NAME CHUNK_OFFSET CHUNK_SIZE 0 CHUNK_XSIZE
            else
                clog NAME CHUNK_OFFSET CHUNK_ZSIZE CHUNK_SIZE 0 CHUNK_XSIZE
            endif
            math TMP_SIZE - CHUNK_SIZE
        next x
        append
    else
        savepos BASE_OFF TOC_FILE
        math BASE_OFF - TMP_OFF
        math OFFSET + BASE_OFF
        math XSIZE = ZSIZE
        if ENCRYPTED == 0
            filexor ""
        endif
        if ZIP == 0
            log NAME OFFSET SIZE 0 XSIZE
        else
            clog NAME OFFSET ZSIZE SIZE 0 XSIZE
        endif
    endif
    filexor ""
    encryption "" ""
    if ALTERNATIVE_MODE != 0
        math OFFSET + ZSIZE
        goto OFFSET
        if OFFSET == MAX_OFF
            break
        endif
        if VERSION >= 8
            padding 0x800
        endif
    endif
next i
'''

class a_xxgwj:
    RESET = "\033[0m"
    RED   = "\033[1;31m"
    GREEN = "\033[1;32m"
    YELLOW= "\033[1;33m"
    BLUE  = "\033[1;34m"
    MAGENTA="\033[1;35m"
    CYAN  = "\033[1;36m"
    WHITE = "\033[1;37m"

def chmod_x(f: Path):
    if not f.exists():
        print(a_xxgwj.RED + f"找不到 {f}" + a_xxgwj.RESET); sys.exit(1)
    if not os.access(f, os.X_OK):
        f.chmod(f.stat().st_mode | 0o111)
chmod_x(QBMS_EXE)
QEMU_NAME = "qemu-i386"
QEMU_LOCAL = AASE / QEMU_NAME
if QEMU_LOCAL.exists(): chmod_x(QEMU_LOCAL)

def find_tool(name, local: Path):
    loc = local / name
    if loc.exists(): return str(loc)
    if shutil.which(name): return name
    print(a_xxgwj.RED + f"找不到 {name}" + a_xxgwj.RESET); sys.exit(1)
QEMU = find_tool(QEMU_NAME, AASE)
QBMS = str(QBMS_EXE)

_tmp_bms = None
def release_bms(content: str):
    global _tmp_bms
    fd, _tmp_bms = tempfile.mkstemp(suffix=".bms", prefix="_tmp")
    with os.fdopen(fd, "w", encoding="utf-8") as f:
        f.write(content)
    return _tmp_bms

def cleanup_bms():
    global _tmp_bms
    if _tmp_bms and os.path.isfile(_tmp_bms):
        os.remove(_tmp_bms); _tmp_bms = None

def run(cmd):
    print(a_xxgwj.CYAN + (">>> 正在解包…" if "解包值" in cmd[-1] else ">>> 正在打包…") + a_xxgwj.RESET)
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    summary = False
    for line in p.stdout:
        line = line.rstrip()
        if not line: continue
        if line.lstrip().startswith("- ") and "files" in line and "found" in line:
            summary = True
        if summary: continue
        print(line)
    ret = p.wait()
    if ret:
        print(a_xxgwj.RED + "✘ 失败" + a_xxgwjul.RESET)
        cleanup_bms(); sys.exit(1)

def choose_file(folder: Path, pat="*", title="请选择文件"):
    files = sorted(folder.glob(pat))
    if not files:
        print(a_xxgwj.YELLOW + f"{title} 目录没有匹配文件！" + a_xxgwj.RESET)
        return None
    print(f"\n{title}：")
    for i, f in enumerate(files, 1):
        print(f"{i}. {f.name}")
    try:
        idx = int(input("输入序号：")) - 1
        return files[idx]
    except (ValueError, IndexError):
        print(a_xxgwj.RED + "输入无效！" + a_xxgwj.RESET)
        return None

UASSET_MAGIC = b"\xC1\x83\x2A\x9E"

def is_uasset(data: bytes) -> bool:
    return data.startswith(UASSET_MAGIC)
def rename_by_header(file_path: Path):
    if not file_path.is_file(): return
    with open(file_path, "rb") as f:
        head = f.read(4)
    new_ext = ".uasset" if is_uasset(head) else ".uexp"
    new_path = file_path.with_suffix(new_ext)
    if new_path != file_path:
        file_path.rename(new_path)

def unpack_dat():
    pak = choose_file(ORIG_PAK, "*.pak", "原版PAK")
    if not pak:
        return
    out = UNPACK_DIR / pak.stem / "DAT"

    if out.exists():
        ans = input(f"目录已存在 [{out.name}] 直接覆盖？(y/n): ").strip().lower()
        if ans != 'y':
            print("已取消解包")
            c_xxgwj()
            return
    else:
        out.mkdir(parents=True, exist_ok=True)

    pack_sub = PACK_DIR / pak.stem / "DAT"
    pack_sub.mkdir(parents=True, exist_ok=True)
    bms = release_bms(BMS_DAT)
    try:
        cmd = [QEMU, QBMS, "-w", bms, str(pak), str(out)]
        p = subprocess.Popen(cmd,
                             stdin=subprocess.PIPE,
                             stdout=None,
                             stderr=None,
                             universal_newlines=True)
        p.stdin.write("a\n")
        p.stdin.close()
        ret = p.wait()
        if ret:
            print(a_xxgwj.RED + "✘ 失败" + a_xxgwj.RESET)
            cleanup_bms()
            sys.exit(1)
        print(" ")
        print(a_xxgwj.GREEN + "✔ DAT 解包完成！" + a_xxgwj.RESET)
    finally:
        cleanup_bms()
    c_xxgwj()

def pack_dat():
    pak = choose_file(ORIG_PAK, "*.pak", "选择原版PAK")
    if not pak:
        return
    src_dir = PACK_DIR / pak.stem / "DAT"
    src_dir.mkdir(parents=True, exist_ok=True)
    if not any(src_dir.iterdir()):
        print(a_xxgwj.YELLOW + f"打包值/{pak.stem}/DAT 为空，请放入文件后再试。" + a_xxgwj.RESET)
        c_xxgwj()
        return
    out_pak = OUT_PAK_DIR / f"{pak.stem}.pak"
    shutil.copy2(pak, out_pak)
    bms = release_bms(BMS_DAT)
    try:
        cmd = [QEMU, QBMS, "-w", "-r", "-r", bms, str(out_pak), str(src_dir)]
        ret = subprocess.call(cmd, stdin=sys.stdin)
        if ret:
            print(a_xxgwj.RED + "✘ 打包失败" + a_xxgwj.RESET)
            sys.exit(1)
        print(" ")
        print(a_xxgwj.GREEN + f"✔ DAT 打包完成 和平工具/打包输出/{pak.stem}.pak" + a_xxgwj.RESET)
    finally:
        cleanup_bms()
    c_xxgwj()

from tqdm import tqdm
import time

def unpack_uasset():
    pak = choose_file(ORIG_PAK, "*.pak", "原版PAK")
    if not pak:
        return
    out = UNPACK_DIR / pak.stem / "UASSET"
    if out.exists():
        ans = input(f"目录已存在 [{out.name}] 直接覆盖？(y/n): ").strip().lower()
        if ans != 'y':
            print("已取消解包")
            c_xxgwj()
            return
        shutil.rmtree(out)
    out.mkdir(parents=True)

    bms = release_bms(BMS_DAT)
    try:
        # 使用 tqdm 显示进度条
        with tqdm(total=100, desc="进度条可能不准 解包进度", unit="%") as pbar:
            process = subprocess.Popen(
                [QEMU, QBMS, bms, str(pak), str(out)],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            for line in process.stderr:
                if "progress" in line.lower():
                    try:
                        progress = int(line.split(":")[1].strip().rstrip("%"))
                        pbar.update(progress - pbar.n)  # 更新进度条
                    except (ValueError, IndexError):
                        pass  # 如果格式不匹配，跳过
                else:
                    pbar.update(1)  # 如果没有明确的进度信息，逐步更新进度条

            process.wait()

        for f in out.rglob("*"):
            if f.is_file():
                rename_by_header(f)

        entries = sorted([*out.rglob("*.uasset"), *out.rglob("*.uexp")],
                         key=lambda p: int(p.stem))

        print("\n>>> 正在 UASSET 解包…")
        print("  offset   filesize   filename")
        print("--------------------------------------")
        off = 0
        for ef in entries:
            size = ef.stat().st_size
            print(f"+ {off:08x} {size:<10} {ef.name}")
            off += size
            time.sleep(0.05)
        print("\n✔ UASSET 解包完成！")

        (PACK_DIR / pak.stem / "UASSET").mkdir(parents=True, exist_ok=True)
        (PACK_DIR / pak.stem / "DAT").mkdir(parents=True, exist_ok=True)
    finally:
        cleanup_bms()
    c_xxgwj()

def pack_uasset():
    pak = choose_file(ORIG_PAK, "*.pak", "选择原版PAK")
    if not pak:
        return
    src = PACK_DIR / pak.stem / "UASSET"
    src.mkdir(parents=True, exist_ok=True)
    files = [f for f in src.rglob("*") if f.is_file() and f.suffix in {".uasset", ".uexp"}]
    if not files:
        c_xxgwj()
        return

    bak = {f.with_suffix(".dat"): f for f in files}
    for tmp, orig in bak.items():
        orig.rename(tmp)

    out_pak = OUT_PAK_DIR / f"{pak.stem}.pak"
    shutil.copy2(pak, out_pak)
    bms = release_bms(BMS_DAT)

    try:
        print("正在 UASSET 打包…")
        
        p = subprocess.Popen(
            [QEMU, QBMS, "-w", "-r", bms, str(out_pak), str(src)],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
        )
        p.stdin.write("y\n")
        p.stdin.close()

        # 使用 tqdm 显示进度条
        with tqdm(total=100, desc="进度条可能不准 打包进度", unit="%"+"进度条可能不准") as pbar:
            for line in p.stderr:
                if "progress" in line.lower():
                    try:
                        progress = int(line.split(":")[1].strip().rstrip("%"))
                        pbar.update(progress - pbar.n)  # 更新进度条
                    except (ValueError, IndexError):
                        pass  # 如果格式不匹配，跳过
                else:
                    pbar.update(1)  # 如果没有明确的进度信息，逐步更新进度条

        print("  offset   filesize   filename")
        print("--------------------------------------")
        for line in p.stdout:
            m = re.match(r"<\s+([0-9a-f]+)\s+(\d+)\s+(\d+\.dat)", line.strip(), re.I)
            if not m:
                continue
            off, size, dat = m.groups()
            orig = bak[src / dat]
            print(f"✔ {off:>8} {size:<10} {orig.name}")
            time.sleep(0.05)

        p.wait()
        print(f"\n✔打包完成 {out_pak}")
    finally:
        for tmp, orig in bak.items():
            tmp.rename(orig)
        cleanup_bms()
    c_xxgwj()

def c_xxgwj():
    input(f"\n{a_xxgwj.CYAN}按回车键返回菜单 {a_xxgwj.RESET}(Press Enter to return to menu)")
    os.system('cls' if os.name == 'nt' else 'clear')
    banner()

def clean_unpack():
    if UNPACK_DIR.exists():
        shutil.rmtree(UNPACK_DIR)
        UNPACK_DIR.mkdir(parents=True)
        print(a_xxgwj.GREEN + "✔ 解包输出已清空" + a_xxgwj.RESET)
    c_xxgwj()

def banner():
    time.sleep(0.08)
    print(a_xxgwj.CYAN + r"""
██╗  ██╗██╗  ██╗████████╗ ██████╗  ██████╗ ██╗     
╚██╗██╔╝╚██╗██╔╝╚══██╔══╝██╔═══██╗██╔═══██╗██║     
 ╚███╔╝  ╚███╔╝    ██║   ██║   ██║██║   ██║██║     
 ██╔██╗  ██╔██╗    ██║   ██║   ██║██║   ██║██║     
██╔╝ ██╗██╔╝ ██╗   ██║   ╚██████╔╝╚██████╔╝███████╗
╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝
""" + a_xxgwj.RESET)

GUNS = {
    "BP_Sniper_M24_C":             ("狙击枪", "M24"),
    "BP_Sniper_Mk14_C":            ("狙击枪", "Mk14"),
    "BP_Sniper_AWM_C":             ("狙击枪", "AWM"),
    "BP_Sniper_M98K_C":            ("狙击枪", "M98K"),
    "BP_Sniper_VSS_C":             ("狙击枪", "VSS"),
    "BP_Sniper_MINI14_C":          ("狙击枪", "MINI14"),
    "BP_Sniper_SLR_C":             ("狙击枪", "SLR"),
    "BP_Sniper_Win94_C":           ("狙击枪", "Win94"),
    "BP_Other_CrossBow":           ("弩", "十字弩"),
    "BP_Other_MachineCrossBow_C":  ("弩", "机关弩"),
    "BP_Rifle_ARX200_C":           ("步枪", "ARX200"),
    "BP_Rifle_M762_C":             ("步枪", "M762"),
    "BP_Rifle_M416_C":             ("步枪", "M416"),
    "BP_Rifle_AKM_C":              ("步枪", "AKM"),
    "BP_Rifle_SCAR_C":             ("步枪", "SCAR"),
    "BP_Rifle_AUG_C":              ("步枪", "AUG"),
    "BP_Rifle_Groza_C":            ("步枪", "Groza"),
    "BP_Rifle_FAMAS_C":            ("步枪", "FAMAS"),
    "BP_Rifle_QBZ_C":              ("步枪", "QBZ"),
    "BP_Rifle_G36C_C":             ("步枪", "G36C"),
    "BP_Rifle_M16A4_C":            ("步枪", "M16A4"),
    "BP_Rifle_Mk47_C":             ("步枪", "Mk47"),
    "BP_MachineGun_PP19_C":        ("冲锋枪", "PP19"),
    "BP_MachineGun_P90_C":         ("冲锋枪", "P90"),
    "BP_MachineGun_AKS74U_C":      ("冲锋枪", "AKS74U"),
    "BP_MachineGun_UMP45_C":       ("冲锋枪", "UMP45"),
    "BP_MachineGun_Vector_C":      ("冲锋枪", "Vector"),
    "BP_MachineGun_Tommy_C":       ("冲锋枪", "Tommy"),
    "BP_MachineGun_MP5K_C":        ("冲锋枪", "MP5K"),
    "BP_MachineGun_Bizon_C":       ("冲锋枪", "Bizon"),
    "BP_MachineGun_Uzi_C":         ("冲锋枪", "Uzi"),
    "BP_Other_DP28_C":             ("机枪", "DP28"),
    "BP_Other_M249_C":             ("机枪", "M249"),
    "BP_Other_MG3_C":              ("机枪", "MG3"),
    "BP_Other_MG36_C":             ("机枪", "MG36"),
    "BP_Other_PKM_C":              ("机枪", "PKM"),
    "BP_Other_SIG_M338_C":         ("机枪", "M338"),
    "BP_Shotgun_S1897_C":          ("霰弹枪", "S1897"),
    "BP_Shotgun_S12K_C":           ("霰弹枪", "S12K"),
    "BP_Shotgun_S686_C":           ("霰弹枪", "S686"),
    "BP_Shotgun_DBS_C":            ("霰弹枪", "DBS"),
    "BP_ShotGun_SPAS12_C":         ("霰弹枪", "SPAS12"),
    "BP_Pistol_P92_C":             ("手枪", "P92"),
    "BP_Pistol_P1911_C":           ("手枪", "P1911"),
    "BP_Pistol_R1895_C":           ("手枪", "R1895"),
    "BP_Pistol_R45_C":             ("手枪", "R45"),
    "BP_Pistol_SawedOff_C":        ("手枪", "SawedOff"),
    "BP_Pistol_Skorpion_C":        ("手枪", "Skorpion"),
    "BP_Pistol_FN57_C":            ("手枪", "FN57"),
    "BP_Pistol_DesertEagle_C":     ("手枪", "DesertEagle"),
    "BP_Pistol_P18C_C":            ("手枪", "P18C")
}

def copy_pair(uasset: Path, out_dir: Path):
    out_dir.mkdir(parents=True, exist_ok=True)
    shutil.copy2(uasset, out_dir / uasset.name)
    num = int(re.search(r'(\d+)', uasset.stem).group(1)) + 1
    uexp = uasset.with_name(f'{num:08d}.uexp')
    if uexp.exists():
        shutil.copy2(uexp, out_dir / uexp.name)

def main_yjssq():
    root  = Path(input('UASSET目录路径: ').strip())
    pak   = root.parent.name          # 取上一级目录名作为pak名
    out   = Path('/storage/emulated/0/Download/XIAOXUAN/枪械搜索输出') / pak
    files = list(root.glob('*.uasset'))
    if not files:
        print('未找到.uasset文件'); return

    stats = {}
    for f in files:
        txt = f.read_text(errors='ignore')
        for key, (cat, short) in GUNS.items():
            if key in txt:
                copy_pair(f, out / cat / short)
                stats.setdefault(cat, {}).setdefault(short, 0)
                stats[cat][short] += 1
                break

    (out / '提取统计.json').write_text(json.dumps(stats, ensure_ascii=False, indent=2))
    print(f'完成，共{sum(sum(v.values()) for v in stats.values())}个资源 → {out}')

def menu():
    os.system('cls' if os.name == 'nt' else 'clear')
    banner()
    while True:
        print(a_xxgwj.YELLOW + "1. DAT 解包" + a_xxgwj.RESET)
        print(a_xxgwj.YELLOW + "2. DAT 打包" + a_xxgwj.RESET)
        print(a_xxgwj.YELLOW + "3. UASSET 解包" + a_xxgwj.RESET)
        print(a_xxgwj.YELLOW + "4. UASSET 打包" + a_xxgwj.RESET)
        print(a_xxgwj.YELLOW + "5. 一键搜索枪值" + a_xxgwj.RESET)
        print(a_xxgwj.YELLOW + "6. 清除解包文件" )
        print("7. 退出工具")
        sel = input("请选择：").strip()
        if sel == "1":
            unpack_dat()
        elif sel == "2":
            pack_dat()
        elif sel == "3":
            unpack_uasset()
        elif sel == "4":
            pack_uasset()
        elif sel == "5":
            main_yjssq()
        elif sel == "6":
            clean_unpack()
            c_xxgwj()
        elif sel == "7":
            print(a_xxgwj.YELLOW + "再见！" + a_xxgwj.RESET)
            break
        else:
            print(a_xxgwj.RED + "输入无效！" + a_xxgwj.RESET)

if __name__ == "__main__":
    try:
        menu()
    except KeyboardInterrupt:
        print(a_xxgwj.YELLOW + "\n用户中断。" + a_xxgwj.RESET)
    finally:
        cleanup_bms()